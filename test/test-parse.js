'use strict'

const tap = require('tap')
const Api = require('../api')

tap.test('api parse > no explicit types', t => {
  return Api.get().parse('-xyz hello there --xyz friend ------a=nice to see -u').then(result => {
    t.equal(result.code, 0)
    t.equal(result.output, '')
    t.same(result.errors, [])
    t.same(result.argv._, ['there', 'to', 'see'])
    t.equal(result.argv.x, true)
    t.equal(result.argv.y, true)
    t.equal(result.argv.z, 'hello')
    t.equal(result.argv.xyz, 'friend')
    t.equal(result.argv.a, 'nice')
    t.equal(result.argv.u, true)
    t.same(result.details.args, ['-xyz', 'hello', 'there', '--xyz', 'friend', '------a=nice', 'to', 'see', '-u'])
  })
})

tap.test('api parse > basic types', t => {
  return Api.get()
    .boolean('-b, --bool')
    .enumeration('-e, --enum <choice>', {
      choices: ['one', 'two', 'three']
    })
    .number('-n, --number <num>')
    .path('-p, --path <path>')
    .file('-f, --file <file>')
    .dir('-d, --dir <dir>')
    .string('-s, --string <str>')
    .parse('-b a --enum two b -n 0 c --path=local d e -f package.json f g --dir node_modules h -s "hello there" i')
    .then(result => {
      t.equal(result.code, 0)
      t.equal(result.output, '')
      t.same(result.errors, [])
      // argv
      t.same(result.argv._, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])
      t.equal(result.argv.b, true)
      t.equal(result.argv.bool, true)
      t.notOk(result.argv.choice)
      t.equal(result.argv.e, 'two')
      t.equal(result.argv.enum, 'two')
      t.equal(result.argv.n, 0)
      t.equal(result.argv.number, 0)
      t.notOk(result.argv.num)
      t.equal(result.argv.p, 'local')
      t.equal(result.argv.path, 'local')
      t.equal(result.argv.f, 'package.json')
      t.equal(result.argv.file, 'package.json')
      t.equal(result.argv.d, 'node_modules')
      t.equal(result.argv.dir, 'node_modules')
      t.equal(result.argv.s, 'hello there')
      t.equal(result.argv.string, 'hello there')
      t.notOk(result.argv.str)
      // details.args
      t.same(result.details.args, [
        '-b', 'a', '--enum', 'two', 'b', '-n', '0', 'c', '--path=local', 'd',
        'e', '-f', 'package.json', 'f', 'g', '--dir', 'node_modules', 'h',
        '-s', 'hello there', 'i'
      ])
      // details.types
      t.equal(result.details.types[0].parent, 'test-parse')
      t.same(result.details.types[0].aliases, ['_'])
      t.equal(result.details.types[0].datatype, 'array:string')
      t.same(result.details.types[0].value, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])
      t.equal(result.details.types[0].source, 'positional')
      t.same(result.details.types[0].position, [1, 4, 7, 9, 10, 13, 14, 17, 20])
      t.same(result.details.types[0].raw, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])

      t.equal(result.details.types[1].parent, 'test-parse')
      t.same(result.details.types[1].aliases, ['b', 'bool'])
      t.equal(result.details.types[1].datatype, 'boolean')
      t.equal(result.details.types[1].value, true)
      t.equal(result.details.types[1].source, 'flag')
      t.same(result.details.types[1].position, [0])
      t.same(result.details.types[1].raw, ['-b'])

      t.equal(result.details.types[2].parent, 'test-parse')
      t.same(result.details.types[2].aliases, ['e', 'enum'])
      t.equal(result.details.types[2].datatype, 'string')
      t.equal(result.details.types[2].value, 'two')
      t.equal(result.details.types[2].source, 'flag')
      t.same(result.details.types[2].position, [2, 3])
      t.same(result.details.types[2].raw, ['--enum', 'two'])

      t.equal(result.details.types[3].parent, 'test-parse')
      t.same(result.details.types[3].aliases, ['n', 'number'])
      t.equal(result.details.types[3].datatype, 'number')
      t.equal(result.details.types[3].value, 0)
      t.equal(result.details.types[3].source, 'flag')
      t.same(result.details.types[3].position, [5, 6])
      t.same(result.details.types[3].raw, ['-n', '0'])

      t.equal(result.details.types[4].parent, 'test-parse')
      t.same(result.details.types[4].aliases, ['p', 'path'])
      t.equal(result.details.types[4].datatype, 'path')
      t.equal(result.details.types[4].value, 'local')
      t.equal(result.details.types[4].source, 'flag')
      t.same(result.details.types[4].position, [8])
      t.same(result.details.types[4].raw, ['--path=local'])

      t.equal(result.details.types[5].parent, 'test-parse')
      t.same(result.details.types[5].aliases, ['f', 'file'])
      t.equal(result.details.types[5].datatype, 'file')
      t.equal(result.details.types[5].value, 'package.json')
      t.equal(result.details.types[5].source, 'flag')
      t.same(result.details.types[5].position, [11, 12])
      t.same(result.details.types[5].raw, ['-f', 'package.json'])

      t.equal(result.details.types[6].parent, 'test-parse')
      t.same(result.details.types[6].aliases, ['d', 'dir'])
      t.equal(result.details.types[6].datatype, 'dir')
      t.equal(result.details.types[6].value, 'node_modules')
      t.equal(result.details.types[6].source, 'flag')
      t.same(result.details.types[6].position, [15, 16])
      t.same(result.details.types[6].raw, ['--dir', 'node_modules'])

      t.equal(result.details.types[7].parent, 'test-parse')
      t.same(result.details.types[7].aliases, ['s', 'string'])
      t.equal(result.details.types[7].datatype, 'string')
      t.equal(result.details.types[7].value, 'hello there')
      t.equal(result.details.types[7].source, 'flag')
      t.same(result.details.types[7].position, [18, 19])
      t.same(result.details.types[7].raw, ['-s', 'hello there'])
    })
})

tap.test('api parse > multiple sequential passes', t => {
  const api = Api.get()
    .option('-b | --bool', { type: 'boolean' })
    .option('-s | --str', { type: 'string' })
  return api.parse('').then(result => {
    t.equal(result.argv.b, false)
    t.equal(result.argv.bool, false)
    t.equal(result.argv.s, undefined)
    t.equal(result.argv.str, undefined)
    t.same(result.argv._, [])
    return api.parse('--bool false -s')
  }).then(result => {
    t.equal(result.argv.b, false)
    t.equal(result.argv.bool, false)
    t.equal(result.argv.s, '')
    t.equal(result.argv.str, '')
    t.same(result.argv._, [])
    return api.parse(['hi', '--str', 'there', '-b=true'])
  }).then(result => {
    t.equal(result.argv.b, true)
    t.equal(result.argv.bool, true)
    t.equal(result.argv.s, 'there')
    t.equal(result.argv.str, 'there')
    t.same(result.argv._, ['hi'])
  })
})

tap.test('api parse > multiple concurrent passes', t => {
  const api = Api.get()
    .boolean('--bool | -b')
    .string('--str  | -s <value>')
  const promises = []
  promises.push(api.parse('-b -s one').then(result => {
    t.equal(result.argv.b, true)
    t.equal(result.argv.bool, true)
    t.equal(result.argv.s, 'one')
    t.equal(result.argv.str, 'one')
    t.same(result.argv._, [])
  }))
  promises.push(api.parse('--str two second').then(result => {
    t.equal(result.argv.b, false)
    t.equal(result.argv.bool, false)
    t.equal(result.argv.s, 'two')
    t.equal(result.argv.str, 'two')
    t.same(result.argv._, ['second'])
  }))
  promises.push(api.parse('third --bool').then(result => {
    t.equal(result.argv.b, true)
    t.equal(result.argv.bool, true)
    t.equal(result.argv.s, undefined)
    t.equal(result.argv.str, undefined)
    t.same(result.argv._, ['third'])
  }))
  return Promise.all(promises)
})

tap.test('api parse > array types')
tap.test('api parse > strict types')
tap.test('api parse > help')
tap.test('api parse > version')
tap.test('api parse > top-level positionals')
tap.test('api parse > commands')
